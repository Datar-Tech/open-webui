好的，這是一份根據您提供的逐字稿和重點生成的會議摘要。

---

### **會議摘要**

**日期：** 2025年7月6日
**與會者：** Roger Hsu, Kai
**主題：** 研討 Open WebUI 後端架構，以支援具備多次工具調用能力的 Agent

---

### **總體結論**

本次會議深入分析了 Open WebUI 現有的後端程式碼，以解決 Function/Pipeline 無法進行多次工具調用的核心問題。會議確定，當前架構的設計並非針對 Agent，其工具調用機制會攔截並執行工具，導致 Agent 無法接收工具的完整資訊以進行後續的思考與鏈式調用。

最終的共識是，需要為 Agent 打造專屬的後端處理流程，可能是透過修改現有程式碼，增加一個「Agent 模式」。首要任務是透過偵錯來徹底釐清前端工具資訊（Tool Discovery）的傳遞機制，再決定具體的實施方案。

---

### **詳細討論內容**

#### **第一階段：問題分析與程式碼追蹤 (約 0:39 - 14:00)**

*   **問題起源：** Roger 首先指出，前端呼叫的 `check completion` API 端點是整個流程的起點。目前的 "Function" 模式只能執行一次模型呼叫（Model Call）和一次工具調用（Tool Call），而理想的 "Agent" 模式需要能執行多次模型呼叫與多次工具調用。
*   **程式碼分析：**
    *   Roger 帶領 Kai 追蹤後端程式碼，指出真正的模型呼叫發生在 `generate_chat_completion` 函式中。此處會根據模型類型（OpenAI, Ollama, Pipeline 等）進行路由（Routing）。
    *   關鍵在於，在呼叫模型之前，程式會先執行 `process_chat_payload` 來準備工具說明書等前置資料。
    *   工具的實際執行發生在 `chat_completion_tool_handler` 中。如果模型的回應指示要使用工具，後端會在此處攔截並執行該工具，然後將結果插入最終回應中。
*   **核心發現：** 這個架構導致 Agent（無論是放在 Function 還是 Pipeline 中）無法得知工具調用的中間結果並進行下一步判斷，因為工具的執行被後端主流程控制了，Agent 本身只會看到一次性的結果。

#### **第二階段：探討解決方案與架構方向 (約 14:00 - 40:00)**

*   **討論核心：** 如何讓 Agent 能夠自主進行多次工具調用，而不被 Open WebUI 的現有機制限制。
*   **方案一：工具寫死在 Agent 中 (Hard-coding)**
    *   **做法：** 將所有工具的程式碼直接寫在 Agent（例如 LlamaIndex）的程式碼內部。
    *   **優點：** 可以實現多次工具調用，因為所有邏輯都在 Agent 內部閉環。
    *   **缺點：** 維護性極差。若一個工具被多個 Agent 使用，一旦工具更新，所有相關的 Agent 程式碼都需要手動修改，不具擴展性。
*   **方案二：工具與 Agent 分離 (Decoupling)**
    *   **做法：** 將工具作為獨立服務（例如 MCP 工具或 REST API）部署在專門的伺服器上。Agent 透過標準化的協定（Protocol）來遠端呼叫這些工具。
    *   **優點：** 高度模組化且易於維護。工具可以獨立更新，不影響 Agent。
    *   **挑戰：** Open WebUI 的作者不直接支援 MCP 協定，因此需要將 MCP 工具包裝成 REST API 才能掛載，或者需要自行修改後端以支援 MCP。

#### **第三階段：提出「Agent 模式」與釐清後續方向 (約 40:00 - 結束)**

*   **根本問題：** 與會雙方一致認為，Open WebUI 的現有設計是為了「單次問答 + 工具輔助」，而非為「Agent」設計。
*   **概念提出：** 為了支援真正的 Agent，需要建立一個類似 Copilot 的「Agent 模式」。在此模式下，後端的行為將完全不同：
    1.  後端不再攔截工具調用。
    2.  取而代之的是，後端會將一個**完整的工具發現（Tool Discovery）**資訊包（Payload）傳遞給 Agent。這個資訊包需包含所有可用工具的詳細描述，如：端點（Endpoint）、API 金鑰、參數規格（Schema）等。
    3.  Agent 收到這個完整的資訊包後，就能全權主導整個思考鏈，自行決定何時、如何呼叫哪些工具。
*   **Pipeline vs. Function 的再思考：**
    *   最初從 Pipeline 轉向 Function 的原因是 Pipeline 收不到前端傳來的工具資訊。
    *   會議討論後認為，如果能解決工具發現資訊的傳遞問題，那麼 Agent 放在 Pipeline 或 Function 中就只是運算資源（Computing Resource）在哪個容器（Docker）執行的差異，兩者皆可。
    *   因此，核心問題不在於使用 Pipeline 還是 Function，而在於如何修改後端以正確傳遞完整的工具資訊。

---

### **設定目標**

1.  **短期目標：** 徹底理解 Open WebUI 現有的工具發現（Tool Discovery）機制。
2.  **中期目標：** 根據調查結果，制定修改後端程式碼的方案，以實現一個能向 Agent 傳遞完整工具資訊的「Agent 模式」。
3.  **長期目標：** 建立一個可擴展、易於維護的 Agent 架構，將工具與 Agent 分離，並透過標準化協定進行通訊。

---

### **待辦事項 (Action Items)**

*   **負責人：Kai**
    *   **任務：** 在本地建立 Open WebUI 的偵錯（Debug）環境。
    *   **預期成果：**
        1.  **觀察 Tool Discovery Payload：**
            *   掛載伺服器端（Admin Panel）和使用者端（個人頭像設定）的工具。
            *   啟用原生工具（如檔案上傳、網路搜尋）。
            *   在偵錯模式下，攔截並檢查 `process_chat_payload` 產生的工具資訊包，確認其內容是否包含完整的呼叫資訊（Endpoint, API Key 等）。
        2.  **追蹤 Payload 傳遞路徑：**
            *   分析並比較這個工具資訊包是如何被傳遞到 `Function` 和 `Pipeline` 的。
            *   找出為何目前 `Pipeline` 無法收到這些資訊的根本原因。
    *   **時程：** 盡快完成，預計當天下午與 Roger 再次討論結果。

*   **負責人：Roger Hsu**
    *   **任務：** 提供 Kai 建立偵錯環境所需的支援。
    *   **預期成果：**
        1.  提供設置本地環境的說明文件和相關指令（位於 `roger/Roger.md`）。
        2.  指導如何啟動後端偵錯模式，並將 VSCode Debugger 附加（Attach）到後端程序。
        3.  提供一個簡單的 MCP 測試工具（Echo Server）及其掛載指令，以便 Kai 進行測試。